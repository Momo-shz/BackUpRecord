分支名字：
br_develop_mcu_24N1U1                   A2
br_release_adcu25_mcu_6080_20240103     CM2E
br_develop_mcu_adcu25_integration       CX1E


1. MCU 刷写

MCU programm remark

10pin-DAP connector

1. PFLASH 16MB  program flash
0x8000000 - 0x80FFFFFF    16^6 5*3MB + 1*1MB
2. DF_EEPROM   1MB (data flash 0) for emulate e2prom
0xAF000000 - 0xAF0FFFFFF  16^5 
3. DF1   (12KB data flash 1) e2prom for HSM
0xAFC00000 - 0xAFC1FFFF 
4. DF_UCBS 24KB (data flash 0) UCB 
user configuration block  
UCB 512B * 48  erase max 100times all max 500times
0xAF400000 - 0xAF405FFF 

2.开发笔记
软件详细设计-架构图，模块交互图，数据交互图，系统状态机，子系统状态机
软件模块设计
{
  将子系统执行逻辑按照软件功能进行设计
  每个功能函数可独立执行
  内部不直接操作外部数据
  仅对传入参数做处理
  调用函数时，可知晓操作了哪些外部变量
}
功能测试代码
debug代码，debug记录
error信息，error故障监控--触发式打印
异步处理--各模块仅操作各自行为，根据交互模块的状态执行对应行为
提供测试人员查看信息的串口指令，可打印出必要信息
处理数据流和任务分配
{
  发布-订阅模型
  {
    解耦通信双方：发布者发布消息到消息队列或主题中，多个订阅者可以接收并处理这些消息，而无需知道发布者的具体信息。
    事件驱动架构：适用于实现基于事件的系统，其中不同的组件响应特定的事件。
    扩展性高：容易增加新的订阅者来处理消息，或者增加新的消息类型。
  }

  请求-响应模型
  {
    同步通信：请求方发送请求后等待响应方的处理结果，适用于需要即时反馈的场景。
    直接交互：通常涉及两个固定的参与者，请求方和响应方。
    简单直观：逻辑清晰，易于理解和实施。
  }

  推送模型
  {
    主动性：服务端主动向客户端推送数据，无需客户端发起请求。
    实时性：适合需要实时更新数据的场景，如在线聊天、实时通知等。
    效率问题：可能会过度消耗网络资源和客户端资源。
  }

  拉取模型
  {
    控制性：客户端按需从服务端获取数据，可以有效控制数据流量和访问频率。
    简单实现：实现相对简单，不需要考虑数据的主动推送。
    可能延迟：数据更新不够实时，依赖于客户端的拉取频率。
  }

  消息队列模型
  {
    异步处理：消息队列缓冲消息，使得发送方和接收方可以在不同时间进行处理。
    负载均衡：通过队列可以平衡处理能力，避免突发流量导致系统崩溃。
    可靠性高：即使处理方暂时不可用，消息也不会丢失。
  }

  点对点模型
  {
    直接传输：消息直接从一个节点发送到另一个特定节点。
    简单直接：适用于结构简单、参与节点少的应用场景。
    低延迟：由于直接传输，通常具有较低的通信延迟。
  }

  事件携带状态转移（Event Sourcing）
  {
    事件驱动：系统的状态改变由一系列事件驱动，每个事件都记录状态的一次变化。
    审计友好：便于追踪系统的历史状态和变化。
    复杂性管理：随着事件数量的增加，管理和维护的复杂性也会增加。
  }

  服务总线模型
  {
    集成多功能：支持消息路由、转换和复杂的集成场景。
    灵活性高：方便地添加或移除服务，调整消息流程。
    中心化管理：所有交互通过服务总线进行，便于管理和监控。
  }
}

3. 硬件方案

ORIN-X芯片，总算力508Tops

主SOC	ORIN-X *2
LPDDR5	8GB *4*2 (位宽256bit *2)
UFS3.1	256GB *2
Safety MCU	TC397 *2
千兆以太	1000Base-T1 *8
百兆以太	100Base-T1 *6
万兆以太	10GBase-T1 *2
视频输入	GMSL2 *16
视频输出	GMSL3 *1 + GMSL2 *2
CAN/CAN-FD	19路
LIN	4 路
FlexRay	2 路
DSI3	12路 (4通道DSI3总线)
HSM	内置独立安全加密芯片
高精度定位	内置GNSS + IMU


MCUA支持9路CAN、6路SPI、1路Flexray、2路LIN、2路I2C、1路RGMII、5路UART
MCUB支持10路CAN、5路SPI、1路Flexray、2路LIN、2路I2C、1路RGMII、3路UART

环视相机数据不仅仅需要传递到SOCA/B，还需要通过MIPI to GMSL透传给DHU，环视解串器的配置需要支持SOCA/SOCB以及MCUA，为此环视解串器（Max96712）的1路I2C直接和SOCB连接，另外1路I2C需要通过单极双掷开关（SPDT Switch）实现MCUA和SOCA的选通访问，选通信号由MCUA控制。
类似地，环视透传加串器（MAX96793）I2C也在MCUA和SOCA间选通访问，选通信号由MCUA控制
哨兵模式camera
环视解串器和加串器需要在SOCA/B进入低功耗状态时仍然保持数据链路运行，环视加解串器配置和管理增加MCUA 选项。
环视摄像头* 4 将数据 通过解串器 Deser3(MAX96712)D-PHY 4Lanes --- 加串器(MAX96793)MIPI -> GMSL  --- GMSL DHU     


4. gcc 编译
预处理
编译
汇编
链接

gcc file.c -o file
gcc main.c -o main


5. VMON梳理
VMON通路：
{
  使用芯片监控
  {
    MPQ79500
    上下电控制及时序监控，电压监控（过欠压）
  }
  芯片通讯方式：I2C
  具体使用参数
  监控方式
  监控指标
  {
    79500自带的电压检控功能，实时读取电压值及故障
  }
  监控目的
  {
    监控SOC上电，下电时序故障
    确保工作电压正常
  }
  监控步骤
  {
    VMON初始化
    监控上电时序
    监控电压 NIRQ
    监控下电时序
  }
  
  1. 初始化
  2. 监控上电，下电时序forSOC
  3. 连续监控VMON NIRQpin 指明是否 过欠压
  4. 上报监控到的故障
  
  函数设计
  {
    返回值：通路状态
    返回参数：数据
  }
}


6. memmap
INIT：定义时初始化，影响启动速度，放置场景：一般需要在很早阶段使用到这个变量，比如 在当前模块的InitRunnable执行到之前 就用到了这个变量；
ZEROINIT：定义时不用初始化，影响启动速度，放置场景：结构体类型复杂，不方便手动初始化
NOINIT（推荐）：定义时不用初始化，不影响启动速度，但是使用之前一定需要手动初始化，放置场景：根据自己的功能实现需求，完全可以在InitRunnable或者使用之前做初始化；


遗留问题:
COM 层调用COMCBK 和 COMCBKTOUT 的机制及时机
